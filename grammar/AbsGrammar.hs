

module AbsGrammar where

-- Haskell module generated by the BNF converter




newtype Ident = Ident String deriving (Eq, Ord, Show, Read)
newtype Error = Error String deriving (Eq, Ord, Show, Read)
data Program = Prog [Stmt]
  deriving (Eq, Ord, Show, Read)

data Boolean = BTrue | BFalse
  deriving (Eq, Ord, Show, Read)

data Map = MapKV Value Value
  deriving (Eq, Ord, Show, Read)

data Literal
    = LInt Integer
    | LBool Boolean
    | LStr String
    | LErr Error
    | LArr [Value]
    | LTup [Value]
    | LMap [Map]
  deriving (Eq, Ord, Show, Read)

data Exp
    = ECall Call
    | EVar Ident
    | EInt Integer
    | ETimes Exp Exp
    | EDiv Exp Exp
    | EMod Exp Exp
    | EPlus Exp Exp
    | EMinus Exp Exp
  deriving (Eq, Ord, Show, Read)

data BExp
    = BCall Call
    | BVar Ident
    | BBool Boolean
    | BLt Exp Exp
    | BGt Exp Exp
    | BLe Exp Exp
    | BGe Exp Exp
    | BEq Exp Exp
    | BNot BExp
    | BAnd BExp BExp
    | BOr BExp BExp
  deriving (Eq, Ord, Show, Read)

data Type
    = TInt
    | TBool
    | TError
    | TString
    | TVoid
    | TArray Type
    | TMap Type Type
    | TTuple [Type]
    | TFunc Type Type
  deriving (Eq, Ord, Show, Read)

data Ret = RVoid | RType Type
  deriving (Eq, Ord, Show, Read)

data Param = PVal Ident Type | PRef Ident Type
  deriving (Eq, Ord, Show, Read)

data Func = FLambda [Param] Ret [Stmt] | FFunc Ident
  deriving (Eq, Ord, Show, Read)

data Call = FCall Ident [Value]
  deriving (Eq, Ord, Show, Read)

data Value
    = VExp Exp
    | VBExp BExp
    | VLit Literal
    | VCall Func [Value]
    | VLambda [Param] Ret [Stmt]
  deriving (Eq, Ord, Show, Read)

data Decl
    = DVar Ident Type
    | DVarI Ident Type Value
    | DFunc Ident [Param] Ret [Stmt]
  deriving (Eq, Ord, Show, Read)

data Stmt
    = SDecl Decl
    | SAssign Ident Value
    | SCall Call
    | SIf BExp [Stmt]
    | SIfelse BExp [Stmt] [Stmt]
    | SWhile BExp [Stmt]
    | SFor Ident Integer Integer [Stmt]
    | SReturn Value
    | SDefer Call
  deriving (Eq, Ord, Show, Read)

