\documentclass{article}

\usepackage{listings}

\title{The Language Grammar}
\author{Mikolaj Walczak}

\begin{document}
\maketitle
\clearpage

\section{The lexical structure of Grammar}

\subsection{Identifiers}

Identifiers \textit{Ident} are unquoted strings beginning with a letter,
followed by any combination of letters, digits, and the characters \texttt{\_ '}
reserved words excluded.

\subsection{Literals}

Integer literals \textit{Integer} are nonempty sequences of digits.

String literals \textit{String} have the form
\texttt{"}\textit{x}\texttt{"}\}, where \textit{x} is any sequence of any characters
except \texttt{"} unless preceded by \texttt{$\backslash$}.

Error literals \textit{Error} have the form
\texttt{`}\textit{x}\texttt{`}\}, where \textit{x} is any sequence of any characters
except \texttt{`} unless preceded by \texttt{$\backslash$}.

\subsection{Reserved words and symbols}

The set of reserved words is the set of terminals appearing in the grammar.
Those reserved words that consist of non-letter characters are called symbols,
and they are treated in a different way from those that are similar to
identifiers. The lexer follows rules familiar from languages like Haskell,
C, and Java, including longest match and spacing conventions.

The reserved words used in Grammar are the following:

\begin{center}\begin{tabular}{llll}
\texttt{and} & \texttt{bool} & \texttt{break} & \texttt{continue} \\
\texttt{elif} & \texttt{else} & \texttt{error} & \texttt{false} \\
\texttt{func} & \texttt{if} & \texttt{int} & \texttt{not} \\
\texttt{or} & \texttt{print} & \texttt{return} & \texttt{string} \\
\texttt{true} & \texttt{var} & \texttt{void} & \texttt{while} \\
\end{tabular}\end{center}

The symbols used in Grammar are the following:

\begin{center}\begin{tabular}{llll}
: & , & [ & ] \\
$<$$|$ & $|$$>$ & \{ & \} \\
* & / & \% & + \\
- & ( & ) & $<$ \\
$>$ & $<$= & $>$= & == \\
. & = & -$>$ & ; \\
\end{tabular}\end{center}

\subsection{Comments}

Single-line comments begin with //.Multiple-line comments are  enclosed with /* and */.

\section{The syntactic structure of Grammar}

Non-terminals are enclosed between $<$ and $>$.
The symbols -$>$ (production),  \textbf{$|$}  (union)
and \textbf{eps} (empty rule) belong to the BNF notation.
All other symbols are terminals. \\

\begin{tabular}{lll}
\textit{Program} & -$>$ & \textit{[Stmt]} \\
\textit{Boolean} & -$>$ & \texttt{true} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \texttt{false} \\
\textit{Map} & -$>$ & \textit{Value} \texttt{:} \textit{Value} \\
\textit{[Map]} & -$>$ & \textbf{eps} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Map} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Map} \texttt{,} \textit{[Map]} \\
\textit{Literal} & -$>$ & \textit{Integer} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Boolean} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{String} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Error} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \texttt{[} \textit{[Value]} \texttt{]} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \texttt{$<$$|$} \textit{[Value]} \texttt{$|$$>$} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \texttt{\{} \textit{[Map]} \texttt{\}} \\
\textit{Exp2} & -$>$ & \textit{Call} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Ident} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Integer} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \texttt{(} \textit{Exp} \texttt{)} \\
\textit{Exp1} & -$>$ & \textit{Exp1} \texttt{*} \textit{Exp2} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Exp1} \texttt{/} \textit{Exp2} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Exp1} \texttt{\%} \textit{Exp2} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Exp2} \\
\textit{Exp} & -$>$ & \textit{Exp} \texttt{+} \textit{Exp1} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Exp} \texttt{-} \textit{Exp1} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Exp1} \\
\textit{BExp3} & -$>$ & \textit{Call} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Ident} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Boolean} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \texttt{(} \textit{BExp} \texttt{)} \\
\textit{BExp2} & -$>$ & \textit{Exp} \texttt{$<$} \textit{Exp} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Exp} \texttt{$>$} \textit{Exp} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Exp} \texttt{$<$=} \textit{Exp} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Exp} \texttt{$>$=} \textit{Exp} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Exp} \texttt{==} \textit{Exp} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{BExp3} \\
\textit{BExp1} & -$>$ & \texttt{not} \textit{BExp} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{BExp2} \\
\textit{BExp} & -$>$ & \textit{BExp} \texttt{and} \textit{BExp1} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{BExp} \texttt{or} \textit{BExp1} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{BExp1} \\
\end{tabular}

\begin{tabular}{lll}
\textit{Type} & -$>$ & \texttt{int} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \texttt{bool} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \texttt{error} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \texttt{string} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \texttt{[} \textit{Type} \texttt{]} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \texttt{\{} \textit{Type} \texttt{:} \textit{Type} \texttt{\}} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \texttt{$<$$|$} \textit{[Type]} \texttt{$|$$>$} \\
\textit{[Type]} & -$>$ & \textit{Type} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Type} \texttt{,} \textit{[Type]} \\
\textit{Ret} & -$>$ & \texttt{void} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Type} \\
\textit{Param} & -$>$ & \textit{Ident} \textit{Type} \\
\textit{[Param]} & -$>$ & \textbf{eps} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Param} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Param} \texttt{,} \textit{[Param]} \\
\textit{Call} & -$>$ & \textit{Ident} \texttt{(} \textit{[Value]} \texttt{)} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Ident} \texttt{.} \textit{Ident} \texttt{(} \textit{[Value]} \texttt{)} \\
\textit{Value} & -$>$ & \textit{Literal} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Ident} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Call} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Exp} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{BExp} \\
\textit{[Value]} & -$>$ & \textbf{eps} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Value} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Value} \texttt{,} \textit{[Value]} \\
\textit{Var} & -$>$ & \textit{Ident} \\
\textit{[Var]} & -$>$ & \textbf{eps} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Var} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Var} \texttt{,} \textit{[Var]} \\
\textit{Decl} & -$>$ & \texttt{var} \textit{Ident} \textit{Type} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \texttt{var} \textit{Ident} \textit{Type} \texttt{=} \textit{Value} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \texttt{func} \textit{Ident} \texttt{(} \textit{[Param]} \texttt{)} \texttt{-$>$} \textit{Ret} \texttt{\{} \textit{[Stmt]} \texttt{\}} \\
\textit{Elif} & -$>$ & \texttt{elif} \textit{BExp} \texttt{\{} \textit{[Stmt]} \texttt{\}} \\
\textit{[Elif]} & -$>$ & \textbf{eps} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Elif} \textit{[Elif]} \\
\textit{Else} & -$>$ & \texttt{else} \texttt{\{} \textit{[Stmt]} \texttt{\}} \\
\textit{Stmt} & -$>$ & \texttt{return} \textit{Value} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \texttt{print} \textit{Value} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Decl} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \texttt{if} \textit{BExp} \texttt{\{} \textit{[Stmt]} \texttt{\}} \textit{[Elif]} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \texttt{if} \textit{BExp} \texttt{\{} \textit{[Stmt]} \texttt{\}} \textit{[Elif]} \textit{Else} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \texttt{while} \textit{BExp} \texttt{\{} \textit{[Stmt]} \texttt{\}} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{[Var]} \texttt{=} \textit{Value} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \texttt{break} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \texttt{continue} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Call} \\
\textit{[Stmt]} & -$>$ & \textbf{eps} \\
 & \multicolumn{1}{c}{\textbf{$|$}} & \textit{Stmt} \texttt{;} \textit{[Stmt]} \\
\end{tabular}

\section{Language description}

\subsection{Definitions and Assignments}
\label{def}
Let $T$ represent a type \textbf{Annotation} and let $ident$ be an identifier.

\subsubsection{Variables}
Assuming that type of $value$ matches $T$, $value$ can be one of:
\begin{itemize}
  \setlength\itemsep{.1em}
  \item a value literal
  \item a variable
  \item a function call
  \item an arithmetic expression (if $T$ is \texttt{int})
  \item a boolean expression (if $T$ is \texttt{bool})
\end{itemize}

\texttt{var $ident$ $T$;} --- will declare a variable $ident$ of type~$T$ and
assign it a default value for type~$T$.

\texttt{var $ident$ $T$ = $value$; } --- will declare a variable $ident$ of
type~$T$ and assign it a value of $value$.

\texttt{$ident$ = $value$;} --- will assign a value of $value$ to the variable
$ident$.

\subsubsection{Functions}
\label{def-functions}
\begin{itemize}
  \setlength\itemsep{.1em}
  \item return type $R$ = $T \cup { \texttt{void} }$.
  \item number of parameters $k \geq 0$
  \item parameter identifiers $p_i$ of type $T_i$ where $i = 1..k$
  \item a function body \texttt{[STMT]} --- a list of statements
\end{itemize}

\texttt{func $ident$($p_1$ $T_1$, ..., $p_k$ $T_k$) -> $R$ \{ [STMT] \}} --- will
define a function $ident$ with $k$ parameters, a return type $R$ and a body
\texttt{[STMT]}.

\subsubsection{Basic types}

\begin{table}[h]
\centering
\label{primitive-types}
\begin{tabular}{|l|l|l|l|l|} \hline
\textbf{Type} & \textbf{Annotation} & \textbf{Value literal}               & \textbf{Default} & \textbf{Example}   \\ \hline
Integer       & \texttt{int}        & \texttt{-?\textbackslash d+}         & \texttt{0}       & \texttt{-42}       \\ \hline
String        & \texttt{string}     & \texttt{"(\textbackslash c - '"')*"} & \texttt{""}      & \texttt{"example"} \\ \hline
Error         & \texttt{error}      & \texttt{`(\textbackslash c - '`')*`} & \texttt{``}      & \texttt{`example`} \\ \hline
Boolean       & \texttt{bool}       & \texttt{(true|false)}                & \texttt{false}   & \texttt{true}      \\ \hline
\end{tabular}
\caption{Primitive types}
\end{table}

\subsubsection{Container types}
$T$ represents a type \textbf{Annotation}. $t$ represents a \textbf{Value}
expression for the type~$T$.

\begin{table}[h]
\centering
\label{container-types}
\begin{tabular}{|l|l|l|l|l|} \hline
\textbf{Type} & \textbf{Annotation}                   & \textbf{Value literal}                      & \textbf{Default} \\ \hline
Array         & \texttt{[$T$]}                        & \texttt{[($t$(, $t$)*)?]}                   & \texttt{[]}      \\ \hline
Map           & \texttt{\{$T_1$:$T_2$\}}              & \texttt{\{($t_1$:$t_2$(, $t_1$:$t_2$)*)?\}} & \texttt{\{\}}    \\ \hline
Tuple         & \texttt{<|$T_1$, $T_2$, ..., $T_k$|>} & \texttt{<|$t_1$, $t_2$, ..., $t_k$|>}       & \texttt{*}       \\ \hline
\end{tabular}
\caption{Container types}
\end{table}

* --- Default tuple has all its fields filled with the default values for the
inner types.

\paragraph{Array examples}
\texttt{var arr [int];} \\
\texttt{var arr [int] = [0];} \\
\texttt{var arr [int] = [0, 42];} \\
\texttt{var arr [string] = ["this", "is", "an", "example"];}

\paragraph{Map examples}
\texttt{var map \{string: int\}; }\\
\texttt{var map \{string: int\} = \{"example": 0\};} \\
\texttt{var map \{string: int\} = \{"an": 0, "example": 1\};} \\
\texttt{var map \{int: int\} = \{1: 0, 42: 1\};}

\paragraph{Tuple examples}
\texttt{var tuple <|int, int|>;} \\
\texttt{var tuple <|string, int, int|> = <|"example", 2, 42|>;} \\
\texttt{var tuple <|int, string, int, int|> = <|-2, "example", 1, 2|>;} \\
\texttt{var tuple <|int, <|int, int|>|> = <|-2, <|1, 2|>|>;}

\subsection{Expressions}

\subsubsection{Arithmetic expressions}
Supports standard arithmetic operations $+, -, *, /, \%, ()$ as well as
variables and function calls (if the return type is an \texttt{int}). Arithmetic
expressions can have side effects (a function call).

\paragraph{Examples}
\texttt{2} \\
\texttt{2 + 4 * (4 + 1)} \\
\texttt{2 + x * (y - 1)} \\
\texttt{2 + power(x, 2)}

\subsubsection{Boolean expressions}
Supports standard boolean operations $and, or, not, ()$, arithmetic expressions
comparison $<, >, <=, >=, ==$ as well as variables and function calls (if the
return type is a \texttt{bool}). Boolean expressions can have side effects
(a function call).

\paragraph{Examples}
\texttt{true} \\
\texttt{true or (true and false)} \\
\texttt{(p and not q) or isEven(x)} \\
\texttt{x / 2 == 3 or x < 10}

\subsection{Statements}
All statements must end with a \texttt{;} symbol. We will use \texttt{[STMT]} to
designate a non empty list of statements.

\subsubsection{Definitions and assignments}
As described in \ref{def}.

\subsubsection{Conditional execution}
Let $B_i$ be a boolean expression.

\paragraph{IF}
Conditional instruction must start with an \texttt{if} block \\
\texttt{if $B_0$ \{ \\
  \hspace*{2em} [STMT] \\
\};}

\paragraph{ELIF}
Which may be followed by multiple (0 or more) \texttt{elif} blocks \\
\texttt{if $B_0$ \{ \\
  \hspace*{2em} [STMT] \\
\} elif $B_1$ \{ \\
  \hspace*{2em} [STMT] \\
\} elif ... \{ \\
  \hspace*{2em} [STMT] \\
\};}

\paragraph{ELSE}
And an optional \texttt{else} block \\
\texttt{if $B_0$ \{ \\
  \hspace*{2em} [STMT] \\
\} else \{ \\
  \hspace*{2em} [STMT] \\
\};}

\subsubsection{While loop}
Standard \texttt{while} with \texttt{break} and \texttt{continue} instructions: \\
\texttt{while x < 50 \{ \\
  \hspace*{2em} [STMT] \\
\};}

\subsubsection{Function calls}
Functions can be called like \texttt{isEven(x)}. Types also have builtin
methods which can be called like \texttt{x.ToString()} or \texttt{arr.Length()}.

\subsubsection{Return}
Functions can return value with \texttt{return} keyword.

\subsubsection{Print}
An instructions which prints given value to the screen.

\section{Summary}
Language satisfies the following requirements (24points):
\begin{itemize}
  \item multiple types (1.)
  \item expressions (2.)
  \item while, if..elif..else (3.)
  \item functions with recrusion (4.)
  \item print (5.)
  \item string and type conversion functions (6c.) expressions side-efects (6d.)
  \item static typing (7.)
  \item static variable binding (8.)
  \item runtime errors (9.)
  \item functions with return values (10.)
  \item arrays (11b.), maps (11c.)
  \item function nesting (12.)
  \item tuples (11d.), break-continue (11e.)
\end{itemize}

\end{document}
