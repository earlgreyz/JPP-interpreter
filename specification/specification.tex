\documentclass{article}

\usepackage{listings}

\begin{document}
\section{Definitions and Assignments}
Let $T$ represent a type \textbf{Annotation} and let $ident$ be an identifier.

\subsection{Variables}
Assuming that type of $value$ matches $T$, $value$ can be one of:
\begin{itemize}
  \setlength\itemsep{.1em}
  \item a value literal
  \item a variable/function identifier
  \item a function call
  \item an expression
  \item a boolean expression
\end{itemize}

\texttt{var $ident$ $T$;} --- will declare a variable $ident$ of type~$T$ and
assign it a default value for type~$T$.

\texttt{var $ident$ $T$ = $value$; } --- will declare a variable $ident$ of
type~$T$ and assign it a value of $value$.

\texttt{$ident$ = $value$;} --- will assign a value of $value$ to the variable
$ident$.

\subsection{Functions}
\label{def-functions}
\begin{itemize}
  \setlength\itemsep{.1em}
  \item return type $R$ = $T \cup { \texttt{void} }$.
  \item number of parameters $k \geq 0$
  \item parameter identifiers $p_i$ of type $T_i$ where $i = 1..k$
  \item a function body \texttt{[STMT]} --- a list of statements
\end{itemize}

\texttt{func $ident$($p_1$ $T_1$, ..., $p_k$ $T_k$) -> $R$ \{ [STMT] \}} --- will
define a function $ident$ with $k$ parameters, a return type $R$ and a body
\texttt{[STMT]}.

Parameters are passed to the function by value. In order for a variable to be
passed by reference a type Annotation may be preceded with a \texttt{\&} sign.

\subsection{Types}

\subsubsection{Basic types}

\begin{table}[h]
\centering
\label{primitive-types}
\begin{tabular}{|l|l|l|l|l|} \hline
\textbf{Type} & \textbf{Annotation} & \textbf{Value literal}               & \textbf{Default} & \textbf{Example}   \\ \hline
Integer       & \texttt{int}        & \texttt{-?\textbackslash d+}         & \texttt{0}       & \texttt{-42}       \\ \hline
String        & \texttt{string}     & \texttt{"(\textbackslash c - '"')*"} & \texttt{""}      & \texttt{"example"} \\ \hline
Error         & \texttt{error}      & \texttt{`(\textbackslash c - '`')*`} & \texttt{``}      & \texttt{`example`} \\ \hline
Boolean       & \texttt{bool}       & \texttt{(true|false)}                & \texttt{false}   & \texttt{true}      \\ \hline
\end{tabular}
\caption{Primitive types}
\end{table}

\subsubsection{Container types}
$T$ represents a type \textbf{Annotation}. $t$ represents a \textbf{Value}
expression for the type~$T$.

\begin{table}[h]
\centering
\label{container-types}
\begin{tabular}{|l|l|l|l|l|} \hline
\textbf{Type} & \textbf{Annotation}                   & \textbf{Value literal}                      & \textbf{Default} \\ \hline
Array         & \texttt{[$T$]}                        & \texttt{[($t$(, $t$)*)?]}                   & \texttt{[]}      \\ \hline
Map           & \texttt{\{$T_1$:$T_2$\}}              & \texttt{\{($t_1$:$t_2$(, $t_1$:$t_2$)*)?\}} & \texttt{\{\}}    \\ \hline
Tuple         & \texttt{<|$T_1$, $T_2$, ..., $T_k$|>} & \texttt{<|$t_1$, $t_2$, ..., $t_k$|>}       & \texttt{*}       \\ \hline
\end{tabular}
\caption{Container types}
\end{table}

* --- Default tuple has all its fields filled with the default values for the
inner types.

\paragraph{Array examples}
\texttt{var arr [int];} \\
\texttt{var arr [int] = [0];} \\
\texttt{var arr [int] = [0, 42];} \\
\texttt{var arr [string] = ["this", "is", "an", "example"];}

\paragraph{Map examples}
\texttt{var map \{string: int\}; }\\
\texttt{var map \{string: int\} = \{"example": 0\};} \\
\texttt{var map \{string: int\} = \{"an": 0, "example": 1\};} \\
\texttt{var map \{int: int\} = \{1: 0, 42: 1\};}

\paragraph{Tuple examples}
\texttt{var tuple <|int, int|>;} \\
\texttt{var tuple <|string, int, int|> = <|"example", 2, 42|>;} \\
\texttt{var tuple <|int, string, int, int|> = <|-2, "example", 1, 2|>;} \\
\texttt{var tuple <|int, <|int, int|>|> = <|-2, <|1, 2|>|>;}

\subsubsection{Function type}
$T$ represents a type \textbf{Annotation} and $R$ = $T \cup { \texttt{void} }$.

\begin{table}[h]
\centering
\label{function-type}
\begin{tabular}{|l|l|l|l|} \hline
\textbf{Type} & \textbf{Annotation}  & \textbf{Value literal} & \textbf{Default} \\ \hline
Function      & \texttt{$T$ -> $R$ } & \texttt{*}             & \texttt{nil}     \\ \hline
\end{tabular}
\caption{Function type}
\end{table}

\paragraph{*Lambda functions}
Lambda functions follow the syntax (uses the same assumptions as in \ref{def-functions}):

\texttt{($p_1$ $T_1$, ..., $p_k$ $T_k$) => $R$ \{ [STMT] \}}

\texttt{nil} function is a special value indicating no function. It cannot be
executed and trying to do so will result in a \texttt{Runtime Error}.

\paragraph{Lambda function examples}
\texttt{var lambda int -> int;} \\
\texttt{var lambda int -> int = (x int) => int \{ return x * 2; \};} \\
\texttt{var lambda int -> <|int, int|> = (x int) => <|int, int|> \{ \\
  \hspace*{2em} return <|x, x|>; \\
\};} \\
\texttt{var lambda int -> int -> int = (x int, y int) => int \{ \\
  \hspace*{2em} return x + y; \\
\};} \\
\texttt{var lambda [string] -> string = nil;}

\section{Expressions}

\subsection{Arithmetic expressions}
Supports standard arithmetic operations $+, -, *, /, \%, ()$ as well as
variables and function calls (if the return type is an \texttt{int}). Arithmetic
expressions can have side effects (a function call).

\paragraph{Examples}
\texttt{2} \\
\texttt{2 + 4 * (4 + 1)} \\
\texttt{2 + x * (y - 1)} \\
\texttt{2 + power(x, 2)} \\
\texttt{2 + (x int) => int \{ return x * x; \}(5) }

\subsection{Boolean expressions}
Supports standard boolean operations $and, or, not, ()$, arithmetic expressions
comparison $<, >, <=, >=, ==$ as well as variables and function calls (if the
return type is a \texttt{bool}). Boolean expressions can have side effects
(a function call).

\paragraph{Examples}
\texttt{true} \\
\texttt{true or (true and false)} \\
\texttt{(p and not q) or isEven(x)} \\
\texttt{x / 2 == 3 or x < 10} \\
\texttt{(x int) => bool \{ return x \%2 == 1; \}(5) }

\end{document}
