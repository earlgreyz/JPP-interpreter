\documentclass{article}

\usepackage{listings}

\begin{document}
\section{Definitions and Assignments}
\label{def}
Let $T$ represent a type \textbf{Annotation} and let $ident$ be an identifier.

\subsection{Variables}
Assuming that type of $value$ matches $T$, $value$ can be one of:
\begin{itemize}
  \setlength\itemsep{.1em}
  \item a value literal
  \item a variable/function identifier
  \item a function call
  \item an expression
  \item a boolean expression
\end{itemize}

\texttt{var $ident$ $T$;} --- will declare a variable $ident$ of type~$T$ and
assign it a default value for type~$T$.

\texttt{var $ident$ $T$ = $value$; } --- will declare a variable $ident$ of
type~$T$ and assign it a value of $value$.

\texttt{$ident$ = $value$;} --- will assign a value of $value$ to the variable
$ident$.

\subsection{Functions}
\label{def-functions}
\begin{itemize}
  \setlength\itemsep{.1em}
  \item return type $R$ = $T \cup { \texttt{void} }$.
  \item number of parameters $k \geq 0$
  \item parameter identifiers $p_i$ of type $T_i$ where $i = 1..k$
  \item a function body \texttt{[STMT]} --- a list of statements
\end{itemize}

\texttt{func $ident$($p_1$ $T_1$, ..., $p_k$ $T_k$) -> $R$ \{ [STMT] \}} --- will
define a function $ident$ with $k$ parameters, a return type $R$ and a body
\texttt{[STMT]}.

\subsection{Types}

\subsubsection{Basic types}

\begin{table}[h]
\centering
\label{primitive-types}
\begin{tabular}{|l|l|l|l|l|} \hline
\textbf{Type} & \textbf{Annotation} & \textbf{Value literal}               & \textbf{Default} & \textbf{Example}   \\ \hline
Integer       & \texttt{int}        & \texttt{-?\textbackslash d+}         & \texttt{0}       & \texttt{-42}       \\ \hline
String        & \texttt{string}     & \texttt{"(\textbackslash c - '"')*"} & \texttt{""}      & \texttt{"example"} \\ \hline
Error         & \texttt{error}      & \texttt{`(\textbackslash c - '`')*`} & \texttt{``}      & \texttt{`example`} \\ \hline
Boolean       & \texttt{bool}       & \texttt{(true|false)}                & \texttt{false}   & \texttt{true}      \\ \hline
\end{tabular}
\caption{Primitive types}
\end{table}

\subsubsection{Container types}
$T$ represents a type \textbf{Annotation}. $t$ represents a \textbf{Value}
expression for the type~$T$.

\begin{table}[h]
\centering
\label{container-types}
\begin{tabular}{|l|l|l|l|l|} \hline
\textbf{Type} & \textbf{Annotation}                   & \textbf{Value literal}                      & \textbf{Default} \\ \hline
Array         & \texttt{[$T$]}                        & \texttt{[($t$(, $t$)*)?]}                   & \texttt{[]}      \\ \hline
Map           & \texttt{\{$T_1$:$T_2$\}}              & \texttt{\{($t_1$:$t_2$(, $t_1$:$t_2$)*)?\}} & \texttt{\{\}}    \\ \hline
Tuple         & \texttt{<|$T_1$, $T_2$, ..., $T_k$|>} & \texttt{<|$t_1$, $t_2$, ..., $t_k$|>}       & \texttt{*}       \\ \hline
\end{tabular}
\caption{Container types}
\end{table}

* --- Default tuple has all its fields filled with the default values for the
inner types.

\paragraph{Array examples}
\texttt{var arr [int];} \\
\texttt{var arr [int] = [0];} \\
\texttt{var arr [int] = [0, 42];} \\
\texttt{var arr [string] = ["this", "is", "an", "example"];}

\paragraph{Map examples}
\texttt{var map \{string: int\}; }\\
\texttt{var map \{string: int\} = \{"example": 0\};} \\
\texttt{var map \{string: int\} = \{"an": 0, "example": 1\};} \\
\texttt{var map \{int: int\} = \{1: 0, 42: 1\};}

\paragraph{Tuple examples}
\texttt{var tuple <|int, int|>;} \\
\texttt{var tuple <|string, int, int|> = <|"example", 2, 42|>;} \\
\texttt{var tuple <|int, string, int, int|> = <|-2, "example", 1, 2|>;} \\
\texttt{var tuple <|int, <|int, int|>|> = <|-2, <|1, 2|>|>;}

\section{Expressions}

\subsection{Arithmetic expressions}
Supports standard arithmetic operations $+, -, *, /, \%, ()$ as well as
variables and function calls (if the return type is an \texttt{int}). Arithmetic
expressions can have side effects (a function call).

\paragraph{Examples}
\texttt{2} \\
\texttt{2 + 4 * (4 + 1)} \\
\texttt{2 + x * (y - 1)} \\
\texttt{2 + power(x, 2)}

\subsection{Boolean expressions}
Supports standard boolean operations $and, or, not, ()$, arithmetic expressions
comparison $<, >, <=, >=, ==$ as well as variables and function calls (if the
return type is a \texttt{bool}). Boolean expressions can have side effects
(a function call).

\paragraph{Examples}
\texttt{true} \\
\texttt{true or (true and false)} \\
\texttt{(p and not q) or isEven(x)} \\
\texttt{x / 2 == 3 or x < 10}

\section{Statements}
All statements must end with a \texttt{;} symbol. We will use \texttt{[STMT]} to
designate a non empty list of statements.

\subsection{Definitions and assignments}
As described in \ref{def}.

\subsection{Conditional execution}
Let $B_i$ be a boolean expression.

\paragraph{IF}
Conditional instruction must start with an \texttt{if} block \\
\texttt{if $B_0$ \{ \\
  \hspace*{2em} [STMT] \\
\};}

\paragraph{ELIF}
Which may be followed by multiple (0 or more) \texttt{elif} blocks \\
\texttt{if $B_0$ \{ \\
  \hspace*{2em} [STMT] \\
\} elif $B_1$ \{ \\
  \hspace*{2em} [STMT] \\
\} elif ... \{ \\
  \hspace*{2em} [STMT] \\
\};}

\paragraph{ELSE}
And an optional \texttt{else} block \\
\texttt{if $B_0$ \{ \\
  \hspace*{2em} [STMT] \\
\} else \{ \\
  \hspace*{2em} [STMT] \\
\};}

\subsection{While loop}
Standard \texttt{while} with \texttt{break} and \texttt{continue} instructions: \\
\texttt{while x < 50 \{ \\
  \hspace*{2em} [STMT] \\
\};}

\subsection{Function calls}
Functions can be called like \texttt{isEven(x)}. Types also have builtin
methods which can be called like \texttt{x.ToString()} or \texttt{arr.Length()}.

\subsection{Return}
Functions can return value with \texttt{return} keyword.

\subsection{Print}
An instructions which prints given value to the screen.

\section{Summary}
Language satisfies the following requirements (24points):
\begin{itemize}
  \item multiple types (1.)
  \item expressions (2.)
  \item while, if..elif..else (3.)
  \item functions with recrusion (4.)
  \item print (5.)
  \item string and type conversion functions (6c.) expressions side-efects (6d.)
  \item static typing (7.)
  \item static variable binding (8.)
  \item runtime errors (9.)
  \item functions with return values (10.)
  \item arrays (11b.), maps (11c.)
  \item function nesting (12.)
  \item tuples (11d.), break-continue (11e.)
\end{itemize}

\end{document}
